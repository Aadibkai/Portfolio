{"ast":null,"code":"import { OutModeDirection, deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, percentDenominator } from \"@tsparticles/engine\";\nimport { calcClosestPointOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils.js\";\nimport { PolygonMaskInlineArrangement } from \"./Enums/PolygonMaskInlineArrangement.js\";\nimport { PolygonMaskType } from \"./Enums/PolygonMaskType.js\";\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`,\n  noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`,\n  origin = {\n    x: 0,\n    y: 0\n  },\n  half = 0.5,\n  double = 2;\nexport class PolygonMaskInstance {\n  constructor(container, engine) {\n    this._checkInsidePolygon = position => {\n      var _position$x, _position$y;\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!(options !== null && options !== void 0 && options.enable) || options.type === PolygonMaskType.none || options.type === PolygonMaskType.inline) {\n        return true;\n      }\n      if (!this.raw) {\n        throw new Error(noPolygonFound);\n      }\n      const canvasSize = container.canvas.size,\n        x = (_position$x = position === null || position === void 0 ? void 0 : position.x) !== null && _position$x !== void 0 ? _position$x : getRandom() * canvasSize.width,\n        y = (_position$y = position === null || position === void 0 ? void 0 : position.y) !== null && _position$y !== void 0 ? _position$y : getRandom() * canvasSize.height,\n        indexOffset = 1;\n      let inside = false;\n      for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\n        const pi = this.raw[i],\n          pj = this.raw[j],\n          intersect = pi.y > y !== pj.y > y && x < (pj.x - pi.x) * (y - pi.y) / (pj.y - pi.y) + pi.x;\n        if (intersect) {\n          inside = !inside;\n        }\n      }\n      if (options.type === PolygonMaskType.inside) {\n        return inside;\n      } else {\n        return options.type === PolygonMaskType.outside ? !inside : false;\n      }\n    };\n    this._createPath2D = () => {\n      var _this$paths;\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options || !((_this$paths = this.paths) !== null && _this$paths !== void 0 && _this$paths.length)) {\n        return;\n      }\n      for (const path of this.paths) {\n        var _path$element, _path$path2d;\n        const pathData = (_path$element = path.element) === null || _path$element === void 0 ? void 0 : _path$element.getAttribute(\"d\");\n        if (pathData) {\n          const path2d = new Path2D(pathData),\n            matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(),\n            finalPath = new Path2D(),\n            transform = matrix.scale(this._scale);\n          if (finalPath.addPath) {\n            finalPath.addPath(path2d, transform);\n            path.path2d = finalPath;\n          } else {\n            delete path.path2d;\n          }\n        } else {\n          delete path.path2d;\n        }\n        if ((_path$path2d = path.path2d) !== null && _path$path2d !== void 0 ? _path$path2d : !this.raw) {\n          continue;\n        }\n        path.path2d = new Path2D();\n        const firstIndex = 0,\n          firstPoint = this.raw[firstIndex];\n        path.path2d.moveTo(firstPoint.x, firstPoint.y);\n        this.raw.forEach((pos, i) => {\n          if (i > firstIndex) {\n            var _path$path2d2;\n            (_path$path2d2 = path.path2d) === null || _path$path2d2 === void 0 ? void 0 : _path$path2d2.lineTo(pos.x, pos.y);\n          }\n        });\n        path.path2d.closePath();\n      }\n    };\n    this._downloadSvgPath = async (svgUrl, force) => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const url = svgUrl !== null && svgUrl !== void 0 ? svgUrl : options.url,\n        forceDownload = force !== null && force !== void 0 ? force : false;\n      if (!url || this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const req = await fetch(url);\n      if (!req.ok) {\n        throw new Error(`${errorPrefix} occurred during polygon mask download`);\n      }\n      return this._parseSvgPath(await req.text(), force);\n    };\n    this._drawPoints = () => {\n      if (!this.raw) {\n        return;\n      }\n      for (const item of this.raw) {\n        void this._container.particles.addParticle({\n          x: item.x,\n          y: item.y\n        });\n      }\n    };\n    this._getEquidistantPointByIndex = index => {\n      var _this$raw, _this$paths2, _point$x, _point, _this$offset$x, _this$offset, _point$y, _point2, _this$offset$y, _this$offset2;\n      const container = this._container,\n        options = container.actualOptions,\n        polygonMaskOptions = options.polygon;\n      if (!polygonMaskOptions) {\n        return;\n      }\n      if (!((_this$raw = this.raw) !== null && _this$raw !== void 0 && _this$raw.length) || !((_this$paths2 = this.paths) !== null && _this$paths2 !== void 0 && _this$paths2.length)) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      let offset = 0,\n        point;\n      const baseAccumulator = 0,\n        totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator),\n        distance = totalLength / options.particles.number.value;\n      for (const path of this.paths) {\n        const pathDistance = distance * index - offset;\n        if (pathDistance <= path.length) {\n          point = path.element.getPointAtLength(pathDistance);\n          break;\n        } else {\n          offset += path.length;\n        }\n      }\n      const scale = this._scale;\n      return {\n        x: ((_point$x = (_point = point) === null || _point === void 0 ? void 0 : _point.x) !== null && _point$x !== void 0 ? _point$x : origin.x) * scale + ((_this$offset$x = (_this$offset = this.offset) === null || _this$offset === void 0 ? void 0 : _this$offset.x) !== null && _this$offset$x !== void 0 ? _this$offset$x : origin.x),\n        y: ((_point$y = (_point2 = point) === null || _point2 === void 0 ? void 0 : _point2.y) !== null && _point$y !== void 0 ? _point$y : origin.y) * scale + ((_this$offset$y = (_this$offset2 = this.offset) === null || _this$offset2 === void 0 ? void 0 : _this$offset2.y) !== null && _this$offset$y !== void 0 ? _this$offset$y : origin.y)\n      };\n    };\n    this._getPointByIndex = index => {\n      var _this$raw2;\n      if (!((_this$raw2 = this.raw) !== null && _this$raw2 !== void 0 && _this$raw2.length)) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = this.raw[index % this.raw.length];\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPoint = () => {\n      var _this$raw3;\n      if (!((_this$raw3 = this.raw) !== null && _this$raw3 !== void 0 && _this$raw3.length)) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const coords = itemFromArray(this.raw);\n      return {\n        x: coords.x,\n        y: coords.y\n      };\n    };\n    this._getRandomPointByLength = () => {\n      var _this$raw4, _this$paths3, _this$offset$x2, _this$offset3, _this$offset$y2, _this$offset4;\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (!((_this$raw4 = this.raw) !== null && _this$raw4 !== void 0 && _this$raw4.length) || !((_this$paths3 = this.paths) !== null && _this$paths3 !== void 0 && _this$paths3.length)) {\n        throw new Error(noPolygonDataLoaded);\n      }\n      const path = itemFromArray(this.paths),\n        offset = 1,\n        distance = Math.floor(getRandom() * path.length) + offset,\n        point = path.element.getPointAtLength(distance),\n        scale = this._scale;\n      return {\n        x: point.x * scale + ((_this$offset$x2 = (_this$offset3 = this.offset) === null || _this$offset3 === void 0 ? void 0 : _this$offset3.x) !== null && _this$offset$x2 !== void 0 ? _this$offset$x2 : origin.x),\n        y: point.y * scale + ((_this$offset$y2 = (_this$offset4 = this.offset) === null || _this$offset4 === void 0 ? void 0 : _this$offset4.y) !== null && _this$offset$y2 !== void 0 ? _this$offset$y2 : origin.y)\n      };\n    };\n    this._initRawData = async force => {\n      const options = this._container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      if (options.url) {\n        this.raw = await this._downloadSvgPath(options.url, force);\n      } else if (options.data) {\n        const data = options.data;\n        let svg;\n        if (isString(data)) {\n          svg = data;\n        } else {\n          const getPath = p => `<path d=\"${p}\" />`,\n            path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\n          const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n          svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\n        }\n        this.raw = this._parseSvgPath(svg, force);\n      }\n      this._createPath2D();\n      this._engine.dispatchEvent(\"polygonMaskLoaded\", {\n        container: this._container\n      });\n    };\n    this._parseSvgPath = (xml, force) => {\n      var _svg$getAttribute, _svg$getAttribute2, _options$position;\n      const forceDownload = force !== null && force !== void 0 ? force : false;\n      if (this.paths !== undefined && !forceDownload) {\n        return this.raw;\n      }\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      const parser = new DOMParser(),\n        doc = parser.parseFromString(xml, \"image/svg+xml\"),\n        firstIndex = 0,\n        svg = doc.getElementsByTagName(\"svg\")[firstIndex];\n      let svgPaths = svg.getElementsByTagName(\"path\");\n      if (!svgPaths.length) {\n        svgPaths = doc.getElementsByTagName(\"path\");\n      }\n      this.paths = [];\n      for (let i = 0; i < svgPaths.length; i++) {\n        const path = svgPaths.item(i);\n        if (path) {\n          this.paths.push({\n            element: path,\n            length: path.getTotalLength()\n          });\n        }\n      }\n      const scale = this._scale;\n      this.dimension.width = parseFloat((_svg$getAttribute = svg.getAttribute(\"width\")) !== null && _svg$getAttribute !== void 0 ? _svg$getAttribute : \"0\") * scale;\n      this.dimension.height = parseFloat((_svg$getAttribute2 = svg.getAttribute(\"height\")) !== null && _svg$getAttribute2 !== void 0 ? _svg$getAttribute2 : \"0\") * scale;\n      const position = (_options$position = options.position) !== null && _options$position !== void 0 ? _options$position : {\n          x: 50,\n          y: 50\n        },\n        canvasSize = container.canvas.size;\n      this.offset = {\n        x: canvasSize.width * position.x / percentDenominator - this.dimension.width * half,\n        y: canvasSize.height * position.y / percentDenominator - this.dimension.height * half\n      };\n      return parsePaths(this.paths, scale, this.offset);\n    };\n    this._polygonBounce = (particle, delta, direction) => {\n      const options = this._container.actualOptions.polygon;\n      if (!this.raw || !(options !== null && options !== void 0 && options.enable) || direction !== OutModeDirection.top) {\n        return false;\n      }\n      if (options.type === PolygonMaskType.inside || options.type === PolygonMaskType.outside) {\n        let closest, dx, dy;\n        const pos = particle.getPosition(),\n          radius = particle.getRadius(),\n          offset = 1;\n        for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\n          const pi = this.raw[i],\n            pj = this.raw[j];\n          closest = calcClosestPointOnSegment(pi, pj, pos);\n          const dist = getDistances(pos, closest);\n          [dx, dy] = [dist.dx, dist.dy];\n          if (dist.distance < radius) {\n            segmentBounce(pi, pj, particle.velocity);\n            return true;\n          }\n        }\n        if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\n          const factor = {\n              x: 1,\n              y: 1\n            },\n            diameter = radius * double,\n            inverse = -1;\n          if (pos.x >= closest.x) {\n            factor.x = -1;\n          }\n          if (pos.y >= closest.y) {\n            factor.y = -1;\n          }\n          particle.position.x = closest.x + diameter * factor.x;\n          particle.position.y = closest.y + diameter * factor.y;\n          particle.velocity.mult(inverse);\n          return true;\n        }\n      } else if (options.type === PolygonMaskType.inline && particle.initialPosition) {\n        const dist = getDistance(particle.initialPosition, particle.getPosition()),\n          {\n            velocity\n          } = particle;\n        if (dist > this._moveRadius) {\n          velocity.x = velocity.y * half - velocity.x;\n          velocity.y = velocity.x * half - velocity.y;\n          return true;\n        }\n      }\n      return false;\n    };\n    this._randomPoint = () => {\n      const container = this._container,\n        options = container.actualOptions.polygon;\n      if (!options) {\n        return;\n      }\n      let position;\n      if (options.type === PolygonMaskType.inline) {\n        switch (options.inline.arrangement) {\n          case PolygonMaskInlineArrangement.randomPoint:\n            position = this._getRandomPoint();\n            break;\n          case PolygonMaskInlineArrangement.randomLength:\n            position = this._getRandomPointByLength();\n            break;\n          case PolygonMaskInlineArrangement.equidistant:\n            position = this._getEquidistantPointByIndex(container.particles.count);\n            break;\n          case PolygonMaskInlineArrangement.onePerPoint:\n          case PolygonMaskInlineArrangement.perPoint:\n          default:\n            position = this._getPointByIndex(container.particles.count);\n        }\n      } else {\n        const canvasSize = container.canvas.size;\n        position = {\n          x: getRandom() * canvasSize.width,\n          y: getRandom() * canvasSize.height\n        };\n      }\n      if (this._checkInsidePolygon(position)) {\n        return position;\n      } else {\n        return this._randomPoint();\n      }\n    };\n    this._container = container;\n    this._engine = engine;\n    this.dimension = {\n      height: 0,\n      width: 0\n    };\n    this._moveRadius = 0;\n    this._scale = 1;\n  }\n  clickPositionValid(position) {\n    const options = this._container.actualOptions.polygon;\n    return !!(options !== null && options !== void 0 && options.enable) && options.type !== PolygonMaskType.none && options.type !== PolygonMaskType.inline && this._checkInsidePolygon(position);\n  }\n  draw(context) {\n    var _this$paths4;\n    if (!((_this$paths4 = this.paths) !== null && _this$paths4 !== void 0 && _this$paths4.length)) {\n      return;\n    }\n    const options = this._container.actualOptions.polygon;\n    if (!(options !== null && options !== void 0 && options.enable)) {\n      return;\n    }\n    const polygonDraw = options.draw;\n    if (!polygonDraw.enable) {\n      return;\n    }\n    const rawData = this.raw;\n    for (const path of this.paths) {\n      const path2d = path.path2d;\n      if (!context) {\n        continue;\n      }\n      if (path2d && this.offset) {\n        drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);\n      } else if (rawData) {\n        drawPolygonMask(context, rawData, polygonDraw.stroke);\n      }\n    }\n  }\n  async init() {\n    const container = this._container,\n      polygonMaskOptions = container.actualOptions.polygon,\n      pxRatio = container.retina.pixelRatio;\n    if (!polygonMaskOptions) {\n      return;\n    }\n    this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\n    this._scale = polygonMaskOptions.scale * pxRatio;\n    if (polygonMaskOptions.enable) {\n      await this._initRawData();\n    }\n  }\n  particleBounce(particle, delta, direction) {\n    return this._polygonBounce(particle, delta, direction);\n  }\n  particlePosition(position) {\n    var _this$raw$length, _this$raw5;\n    const options = this._container.actualOptions.polygon,\n      defaultLength = 0;\n    if (!(options !== null && options !== void 0 && options.enable && ((_this$raw$length = (_this$raw5 = this.raw) === null || _this$raw5 === void 0 ? void 0 : _this$raw5.length) !== null && _this$raw$length !== void 0 ? _this$raw$length : defaultLength) > defaultLength)) {\n      return;\n    }\n    return deepExtend({}, position ? position : this._randomPoint());\n  }\n  particlesInitialization() {\n    const options = this._container.actualOptions.polygon;\n    if (options !== null && options !== void 0 && options.enable && options.type === PolygonMaskType.inline && (options.inline.arrangement === PolygonMaskInlineArrangement.onePerPoint || options.inline.arrangement === PolygonMaskInlineArrangement.perPoint)) {\n      this._drawPoints();\n      return true;\n    }\n    return false;\n  }\n  resize() {\n    const container = this._container,\n      options = container.actualOptions.polygon;\n    if (!(options !== null && options !== void 0 && options.enable && options.type !== PolygonMaskType.none)) {\n      return;\n    }\n    if (this.redrawTimeout) {\n      clearTimeout(this.redrawTimeout);\n    }\n    const timeout = 250;\n    this.redrawTimeout = window.setTimeout(() => {\n      void (async () => {\n        await this._initRawData(true);\n        await container.particles.redraw();\n      })();\n    }, timeout);\n  }\n  stop() {\n    delete this.raw;\n    delete this.paths;\n  }\n}\nexport default noPolygonDataLoaded();","map":{"version":3,"names":["OutModeDirection","deepExtend","errorPrefix","getDistance","getDistances","getRandom","isArray","isString","itemFromArray","percentDenominator","calcClosestPointOnSegment","drawPolygonMask","drawPolygonMaskPath","parsePaths","segmentBounce","PolygonMaskInlineArrangement","PolygonMaskType","noPolygonDataLoaded","noPolygonFound","origin","x","y","half","double","PolygonMaskInstance","constructor","container","engine","_checkInsidePolygon","position","_position$x","_position$y","_container","options","actualOptions","polygon","enable","type","none","inline","raw","Error","canvasSize","canvas","size","width","height","indexOffset","inside","i","j","length","pi","pj","intersect","outside","_createPath2D","_this$paths","paths","path","_path$element","_path$path2d","pathData","element","getAttribute","path2d","Path2D","matrix","document","createElementNS","createSVGMatrix","finalPath","transform","scale","_scale","addPath","firstIndex","firstPoint","moveTo","forEach","pos","_path$path2d2","lineTo","closePath","_downloadSvgPath","svgUrl","force","url","forceDownload","undefined","req","fetch","ok","_parseSvgPath","text","_drawPoints","item","particles","addParticle","_getEquidistantPointByIndex","index","_this$raw","_this$paths2","_point$x","_point","_this$offset$x","_this$offset","_point$y","_point2","_this$offset$y","_this$offset2","polygonMaskOptions","offset","point","baseAccumulator","totalLength","reduce","tot","distance","number","value","pathDistance","getPointAtLength","_getPointByIndex","_this$raw2","coords","_getRandomPoint","_this$raw3","_getRandomPointByLength","_this$raw4","_this$paths3","_this$offset$x2","_this$offset3","_this$offset$y2","_this$offset4","Math","floor","_initRawData","data","svg","getPath","p","map","join","namespaces","_engine","dispatchEvent","xml","_svg$getAttribute","_svg$getAttribute2","_options$position","parser","DOMParser","doc","parseFromString","getElementsByTagName","svgPaths","push","getTotalLength","dimension","parseFloat","_polygonBounce","particle","delta","direction","top","closest","dx","dy","getPosition","radius","getRadius","dist","velocity","factor","diameter","inverse","mult","initialPosition","_moveRadius","_randomPoint","arrangement","randomPoint","randomLength","equidistant","count","onePerPoint","perPoint","clickPositionValid","draw","context","_this$paths4","polygonDraw","rawData","stroke","init","pxRatio","retina","pixelRatio","move","particleBounce","particlePosition","_this$raw$length","_this$raw5","defaultLength","particlesInitialization","resize","redrawTimeout","clearTimeout","timeout","window","setTimeout","redraw","stop"],"sources":["C:/Users/Aadib Kazi/Desktop/projects/Website/portfolio-app/src/Component/Desing/Desing1.js"],"sourcesContent":["import { OutModeDirection, deepExtend, errorPrefix, getDistance, getDistances, getRandom, isArray, isString, itemFromArray, percentDenominator, } from \"@tsparticles/engine\";\r\nimport { calcClosestPointOnSegment, drawPolygonMask, drawPolygonMaskPath, parsePaths, segmentBounce } from \"./utils.js\";\r\nimport { PolygonMaskInlineArrangement } from \"./Enums/PolygonMaskInlineArrangement.js\";\r\nimport { PolygonMaskType } from \"./Enums/PolygonMaskType.js\";\r\nconst noPolygonDataLoaded = `${errorPrefix} No polygon data loaded.`, noPolygonFound = `${errorPrefix} No polygon found, you need to specify SVG url in config.`, origin = {\r\n    x: 0,\r\n    y: 0,\r\n}, half = 0.5, double = 2;\r\nexport class PolygonMaskInstance {\r\n    constructor(container, engine) {\r\n        this._checkInsidePolygon = position => {\r\n            const container = this._container, options = container.actualOptions.polygon;\r\n            if (!options?.enable || options.type === PolygonMaskType.none || options.type === PolygonMaskType.inline) {\r\n                return true;\r\n            }\r\n            if (!this.raw) {\r\n                throw new Error(noPolygonFound);\r\n            }\r\n            const canvasSize = container.canvas.size, x = position?.x ?? getRandom() * canvasSize.width, y = position?.y ?? getRandom() * canvasSize.height, indexOffset = 1;\r\n            let inside = false;\r\n            for (let i = 0, j = this.raw.length - indexOffset; i < this.raw.length; j = i++) {\r\n                const pi = this.raw[i], pj = this.raw[j], intersect = pi.y > y !== pj.y > y && x < ((pj.x - pi.x) * (y - pi.y)) / (pj.y - pi.y) + pi.x;\r\n                if (intersect) {\r\n                    inside = !inside;\r\n                }\r\n            }\r\n            if (options.type === PolygonMaskType.inside) {\r\n                return inside;\r\n            }\r\n            else {\r\n                return options.type === PolygonMaskType.outside ? !inside : false;\r\n            }\r\n        };\r\n        this._createPath2D = () => {\r\n            const container = this._container, options = container.actualOptions.polygon;\r\n            if (!options || !this.paths?.length) {\r\n                return;\r\n            }\r\n            for (const path of this.paths) {\r\n                const pathData = path.element?.getAttribute(\"d\");\r\n                if (pathData) {\r\n                    const path2d = new Path2D(pathData), matrix = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix(), finalPath = new Path2D(), transform = matrix.scale(this._scale);\r\n                    if (finalPath.addPath) {\r\n                        finalPath.addPath(path2d, transform);\r\n                        path.path2d = finalPath;\r\n                    }\r\n                    else {\r\n                        delete path.path2d;\r\n                    }\r\n                }\r\n                else {\r\n                    delete path.path2d;\r\n                }\r\n                if (path.path2d ?? !this.raw) {\r\n                    continue;\r\n                }\r\n                path.path2d = new Path2D();\r\n                const firstIndex = 0, firstPoint = this.raw[firstIndex];\r\n                path.path2d.moveTo(firstPoint.x, firstPoint.y);\r\n                this.raw.forEach((pos, i) => {\r\n                    if (i > firstIndex) {\r\n                        path.path2d?.lineTo(pos.x, pos.y);\r\n                    }\r\n                });\r\n                path.path2d.closePath();\r\n            }\r\n        };\r\n        this._downloadSvgPath = async (svgUrl, force) => {\r\n            const options = this._container.actualOptions.polygon;\r\n            if (!options) {\r\n                return;\r\n            }\r\n            const url = svgUrl ?? options.url, forceDownload = force ?? false;\r\n            if (!url || (this.paths !== undefined && !forceDownload)) {\r\n                return this.raw;\r\n            }\r\n            const req = await fetch(url);\r\n            if (!req.ok) {\r\n                throw new Error(`${errorPrefix} occurred during polygon mask download`);\r\n            }\r\n            return this._parseSvgPath(await req.text(), force);\r\n        };\r\n        this._drawPoints = () => {\r\n            if (!this.raw) {\r\n                return;\r\n            }\r\n            for (const item of this.raw) {\r\n                void this._container.particles.addParticle({\r\n                    x: item.x,\r\n                    y: item.y,\r\n                });\r\n            }\r\n        };\r\n        this._getEquidistantPointByIndex = index => {\r\n            const container = this._container, options = container.actualOptions, polygonMaskOptions = options.polygon;\r\n            if (!polygonMaskOptions) {\r\n                return;\r\n            }\r\n            if (!this.raw?.length || !this.paths?.length) {\r\n                throw new Error(noPolygonDataLoaded);\r\n            }\r\n            let offset = 0, point;\r\n            const baseAccumulator = 0, totalLength = this.paths.reduce((tot, path) => tot + path.length, baseAccumulator), distance = totalLength / options.particles.number.value;\r\n            for (const path of this.paths) {\r\n                const pathDistance = distance * index - offset;\r\n                if (pathDistance <= path.length) {\r\n                    point = path.element.getPointAtLength(pathDistance);\r\n                    break;\r\n                }\r\n                else {\r\n                    offset += path.length;\r\n                }\r\n            }\r\n            const scale = this._scale;\r\n            return {\r\n                x: (point?.x ?? origin.x) * scale + (this.offset?.x ?? origin.x),\r\n                y: (point?.y ?? origin.y) * scale + (this.offset?.y ?? origin.y),\r\n            };\r\n        };\r\n        this._getPointByIndex = index => {\r\n            if (!this.raw?.length) {\r\n                throw new Error(noPolygonDataLoaded);\r\n            }\r\n            const coords = this.raw[index % this.raw.length];\r\n            return {\r\n                x: coords.x,\r\n                y: coords.y,\r\n            };\r\n        };\r\n        this._getRandomPoint = () => {\r\n            if (!this.raw?.length) {\r\n                throw new Error(noPolygonDataLoaded);\r\n            }\r\n            const coords = itemFromArray(this.raw);\r\n            return {\r\n                x: coords.x,\r\n                y: coords.y,\r\n            };\r\n        };\r\n        this._getRandomPointByLength = () => {\r\n            const container = this._container, options = container.actualOptions.polygon;\r\n            if (!options) {\r\n                return;\r\n            }\r\n            if (!this.raw?.length || !this.paths?.length) {\r\n                throw new Error(noPolygonDataLoaded);\r\n            }\r\n            const path = itemFromArray(this.paths), offset = 1, distance = Math.floor(getRandom() * path.length) + offset, point = path.element.getPointAtLength(distance), scale = this._scale;\r\n            return {\r\n                x: point.x * scale + (this.offset?.x ?? origin.x),\r\n                y: point.y * scale + (this.offset?.y ?? origin.y),\r\n            };\r\n        };\r\n        this._initRawData = async (force) => {\r\n            const options = this._container.actualOptions.polygon;\r\n            if (!options) {\r\n                return;\r\n            }\r\n            if (options.url) {\r\n                this.raw = await this._downloadSvgPath(options.url, force);\r\n            }\r\n            else if (options.data) {\r\n                const data = options.data;\r\n                let svg;\r\n                if (isString(data)) {\r\n                    svg = data;\r\n                }\r\n                else {\r\n                    const getPath = (p) => `<path d=\"${p}\" />`, path = isArray(data.path) ? data.path.map(getPath).join(\"\") : getPath(data.path);\r\n                    const namespaces = 'xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\r\n                    svg = `<svg ${namespaces} width=\"${data.size.width}\" height=\"${data.size.height}\">${path}</svg>`;\r\n                }\r\n                this.raw = this._parseSvgPath(svg, force);\r\n            }\r\n            this._createPath2D();\r\n            this._engine.dispatchEvent(\"polygonMaskLoaded\", {\r\n                container: this._container,\r\n            });\r\n        };\r\n        this._parseSvgPath = (xml, force) => {\r\n            const forceDownload = force ?? false;\r\n            if (this.paths !== undefined && !forceDownload) {\r\n                return this.raw;\r\n            }\r\n            const container = this._container, options = container.actualOptions.polygon;\r\n            if (!options) {\r\n                return;\r\n            }\r\n            const parser = new DOMParser(), doc = parser.parseFromString(xml, \"image/svg+xml\"), firstIndex = 0, svg = doc.getElementsByTagName(\"svg\")[firstIndex];\r\n            let svgPaths = svg.getElementsByTagName(\"path\");\r\n            if (!svgPaths.length) {\r\n                svgPaths = doc.getElementsByTagName(\"path\");\r\n            }\r\n            this.paths = [];\r\n            for (let i = 0; i < svgPaths.length; i++) {\r\n                const path = svgPaths.item(i);\r\n                if (path) {\r\n                    this.paths.push({\r\n                        element: path,\r\n                        length: path.getTotalLength(),\r\n                    });\r\n                }\r\n            }\r\n            const scale = this._scale;\r\n            this.dimension.width = parseFloat(svg.getAttribute(\"width\") ?? \"0\") * scale;\r\n            this.dimension.height = parseFloat(svg.getAttribute(\"height\") ?? \"0\") * scale;\r\n            const position = options.position ?? {\r\n                x: 50,\r\n                y: 50,\r\n            }, canvasSize = container.canvas.size;\r\n            this.offset = {\r\n                x: (canvasSize.width * position.x) / percentDenominator - this.dimension.width * half,\r\n                y: (canvasSize.height * position.y) / percentDenominator - this.dimension.height * half,\r\n            };\r\n            return parsePaths(this.paths, scale, this.offset);\r\n        };\r\n        this._polygonBounce = (particle, delta, direction) => {\r\n            const options = this._container.actualOptions.polygon;\r\n            if (!this.raw || !options?.enable || direction !== OutModeDirection.top) {\r\n                return false;\r\n            }\r\n            if (options.type === PolygonMaskType.inside || options.type === PolygonMaskType.outside) {\r\n                let closest, dx, dy;\r\n                const pos = particle.getPosition(), radius = particle.getRadius(), offset = 1;\r\n                for (let i = 0, j = this.raw.length - offset; i < this.raw.length; j = i++) {\r\n                    const pi = this.raw[i], pj = this.raw[j];\r\n                    closest = calcClosestPointOnSegment(pi, pj, pos);\r\n                    const dist = getDistances(pos, closest);\r\n                    [dx, dy] = [dist.dx, dist.dy];\r\n                    if (dist.distance < radius) {\r\n                        segmentBounce(pi, pj, particle.velocity);\r\n                        return true;\r\n                    }\r\n                }\r\n                if (closest && dx !== undefined && dy !== undefined && !this._checkInsidePolygon(pos)) {\r\n                    const factor = { x: 1, y: 1 }, diameter = radius * double, inverse = -1;\r\n                    if (pos.x >= closest.x) {\r\n                        factor.x = -1;\r\n                    }\r\n                    if (pos.y >= closest.y) {\r\n                        factor.y = -1;\r\n                    }\r\n                    particle.position.x = closest.x + diameter * factor.x;\r\n                    particle.position.y = closest.y + diameter * factor.y;\r\n                    particle.velocity.mult(inverse);\r\n                    return true;\r\n                }\r\n            }\r\n            else if (options.type === PolygonMaskType.inline && particle.initialPosition) {\r\n                const dist = getDistance(particle.initialPosition, particle.getPosition()), { velocity } = particle;\r\n                if (dist > this._moveRadius) {\r\n                    velocity.x = velocity.y * half - velocity.x;\r\n                    velocity.y = velocity.x * half - velocity.y;\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        this._randomPoint = () => {\r\n            const container = this._container, options = container.actualOptions.polygon;\r\n            if (!options) {\r\n                return;\r\n            }\r\n            let position;\r\n            if (options.type === PolygonMaskType.inline) {\r\n                switch (options.inline.arrangement) {\r\n                    case PolygonMaskInlineArrangement.randomPoint:\r\n                        position = this._getRandomPoint();\r\n                        break;\r\n                    case PolygonMaskInlineArrangement.randomLength:\r\n                        position = this._getRandomPointByLength();\r\n                        break;\r\n                    case PolygonMaskInlineArrangement.equidistant:\r\n                        position = this._getEquidistantPointByIndex(container.particles.count);\r\n                        break;\r\n                    case PolygonMaskInlineArrangement.onePerPoint:\r\n                    case PolygonMaskInlineArrangement.perPoint:\r\n                    default:\r\n                        position = this._getPointByIndex(container.particles.count);\r\n                }\r\n            }\r\n            else {\r\n                const canvasSize = container.canvas.size;\r\n                position = {\r\n                    x: getRandom() * canvasSize.width,\r\n                    y: getRandom() * canvasSize.height,\r\n                };\r\n            }\r\n            if (this._checkInsidePolygon(position)) {\r\n                return position;\r\n            }\r\n            else {\r\n                return this._randomPoint();\r\n            }\r\n        };\r\n        this._container = container;\r\n        this._engine = engine;\r\n        this.dimension = {\r\n            height: 0,\r\n            width: 0,\r\n        };\r\n        this._moveRadius = 0;\r\n        this._scale = 1;\r\n    }\r\n    clickPositionValid(position) {\r\n        const options = this._container.actualOptions.polygon;\r\n        return (!!options?.enable &&\r\n            options.type !== PolygonMaskType.none &&\r\n            options.type !== PolygonMaskType.inline &&\r\n            this._checkInsidePolygon(position));\r\n    }\r\n    draw(context) {\r\n        if (!this.paths?.length) {\r\n            return;\r\n        }\r\n        const options = this._container.actualOptions.polygon;\r\n        if (!options?.enable) {\r\n            return;\r\n        }\r\n        const polygonDraw = options.draw;\r\n        if (!polygonDraw.enable) {\r\n            return;\r\n        }\r\n        const rawData = this.raw;\r\n        for (const path of this.paths) {\r\n            const path2d = path.path2d;\r\n            if (!context) {\r\n                continue;\r\n            }\r\n            if (path2d && this.offset) {\r\n                drawPolygonMaskPath(context, path2d, polygonDraw.stroke, this.offset);\r\n            }\r\n            else if (rawData) {\r\n                drawPolygonMask(context, rawData, polygonDraw.stroke);\r\n            }\r\n        }\r\n    }\r\n    async init() {\r\n        const container = this._container, polygonMaskOptions = container.actualOptions.polygon, pxRatio = container.retina.pixelRatio;\r\n        if (!polygonMaskOptions) {\r\n            return;\r\n        }\r\n        this._moveRadius = polygonMaskOptions.move.radius * pxRatio;\r\n        this._scale = polygonMaskOptions.scale * pxRatio;\r\n        if (polygonMaskOptions.enable) {\r\n            await this._initRawData();\r\n        }\r\n    }\r\n    particleBounce(particle, delta, direction) {\r\n        return this._polygonBounce(particle, delta, direction);\r\n    }\r\n    particlePosition(position) {\r\n        const options = this._container.actualOptions.polygon, defaultLength = 0;\r\n        if (!(options?.enable && (this.raw?.length ?? defaultLength) > defaultLength)) {\r\n            return;\r\n        }\r\n        return deepExtend({}, position ? position : this._randomPoint());\r\n    }\r\n    particlesInitialization() {\r\n        const options = this._container.actualOptions.polygon;\r\n        if (options?.enable &&\r\n            options.type === PolygonMaskType.inline &&\r\n            (options.inline.arrangement === PolygonMaskInlineArrangement.onePerPoint ||\r\n                options.inline.arrangement === PolygonMaskInlineArrangement.perPoint)) {\r\n            this._drawPoints();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    resize() {\r\n        const container = this._container, options = container.actualOptions.polygon;\r\n        if (!(options?.enable && options.type !== PolygonMaskType.none)) {\r\n            return;\r\n        }\r\n        if (this.redrawTimeout) {\r\n            clearTimeout(this.redrawTimeout);\r\n        }\r\n        const timeout = 250;\r\n        this.redrawTimeout = window.setTimeout(() => {\r\n            void (async () => {\r\n                await this._initRawData(true);\r\n                await container.particles.redraw();\r\n            })();\r\n        }, timeout);\r\n    }\r\n    stop() {\r\n        delete this.raw;\r\n        delete this.paths;\r\n    }\r\n}\r\nexport default noPolygonDataLoaded();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}